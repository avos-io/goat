package client

import (
	"context"
	"io"
	"log"
	"sync"

	rpcheader "github.com/avos-io/grpc-websockets/gen"
	"github.com/avos-io/grpc-websockets/internal"
	spb "google.golang.org/genproto/googleapis/rpc/status"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/encoding"
	"google.golang.org/grpc/encoding/proto"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

type ClientStream interface {
	grpc.ClientStream
	readLoop() error
}

func newClientStream(
	ctx context.Context,
	mp *RpcMultiplexer,
	id uint64,
	method string,
	r func(context.Context) (*rpcheader.Rpc, error),
	w func(context.Context, *rpcheader.Rpc) error,
	teardown func(),
) ClientStream {
	cs := &clientStream{
		ctx:      ctx,
		id:       id,
		method:   method,
		codec:    encoding.GetCodec(proto.Name),
		r:        r,
		w:        w,
		teardown: teardown,
		rCh:      make(chan *rpcheader.Body),
	}

	cs.ready.Add(1)
	go cs.readLoop()

	return cs
}

// TODO: should this live in multiplexer or here or separately?
type clientStream struct {
	ctx context.Context

	id     uint64
	method string
	codec  encoding.Codec

	ready     sync.WaitGroup
	header    metadata.MD
	headerErr error

	// Serialises access to r and protects done, headerErr, and trailer
	rmu     sync.Mutex
	r       func(context.Context) (*rpcheader.Rpc, error)
	done    bool
	trailer *rpcheader.Trailer
	rErr    error

	// Serialises access to w
	wmu sync.Mutex
	w   func(context.Context, *rpcheader.Rpc) error

	teardown func()

	rCh chan *rpcheader.Body
}

// Header returns the header metadata received from the server if there
// is any. It blocks if the metadata is not ready to read.
func (cs *clientStream) Header() (metadata.MD, error) {
	cs.ready.Wait()
	return cs.header, cs.headerErr
}

// Trailer returns the trailer metadata from the server, if there is any.
// It must only be called after stream.CloseAndRecv has returned, or
// stream.Recv has returned a non-nil error (including io.EOF).
func (cs *clientStream) Trailer() metadata.MD {
	cs.rmu.Lock()
	defer cs.rmu.Unlock()

	if cs.trailer.GetMetadata() == nil {
		return nil
	}
	md, err := internal.ToMetadata(cs.trailer.Metadata)
	if err != nil {
		log.Panicf("Trailer err: %v", err)
	}
	return md
}

// CloseSend closes the send direction of the stream. It closes the stream
// when non-nil error is met. It is also not safe to call CloseSend
// concurrently with SendMsg.
func (cs *clientStream) CloseSend() error {
	cs.wmu.Lock()
	defer cs.wmu.Unlock()

	log.Printf("client CloseSend")

	tr := rpcheader.Rpc{
		Id: cs.id,
		Header: &rpcheader.RequestHeader{
			Method: cs.method,
		},
		Status: &rpcheader.ResponseStatus{
			Code:    int32(codes.OK),
			Message: codes.OK.String(),
		},
		Trailer: &rpcheader.Trailer{},
	}

	return cs.w(cs.ctx, &tr)
}

// Context returns the context for this stream.
func (wcs *clientStream) Context() context.Context {
	return wcs.ctx
}

// SendMsg is generally called by generated code. On error, SendMsg aborts
// the stream. If the error was generated by the client, the status is
// returned directly; otherwise, io.EOF is returned and the status of
// the stream may be discovered using RecvMsg.
//
// SendMsg blocks until:
//   - There is sufficient flow control to schedule m with the transport, or
//   - The stream is done, or
//   - The stream breaks.
//
// SendMsg does not wait until the message is received by the server. An
// untimely stream closure may result in lost messages. To ensure delivery,
// users should ensure the RPC completed successfully using RecvMsg.
//
// It is safe to have a goroutine calling SendMsg and another goroutine
// calling RecvMsg on the same stream at the same time, but it is not safe
// to call SendMsg on the same stream in different goroutines. It is also
// not safe to call CloseSend concurrently with SendMsg.
func (cs *clientStream) SendMsg(m interface{}) error {
	cs.wmu.Lock()
	defer cs.wmu.Unlock()

	if done, err := cs.readErrorIfDone(); done {
		return err
	}

	body, err := cs.codec.Marshal(m)
	if err != nil {
		cs.teardown()
		return err
	}
	rpc := rpcheader.Rpc{
		Id: cs.id,
		Header: &rpcheader.RequestHeader{
			Method: cs.method,
		},
		Body: &rpcheader.Body{
			Data: body,
		},
	}
	err = cs.w(cs.ctx, &rpc)
	if err != nil {
		cs.teardown()
		return err
	}

	return nil
}

// RecvMsg blocks until it receives a message into m or the stream is
// done. It returns io.EOF when the stream completes successfully. On
// any other error, the stream is aborted and the error contains the RPC
// status.
//
// It is safe to have a goroutine calling SendMsg and another goroutine
// calling RecvMsg on the same stream at the same time, but it is not
// safe to call RecvMsg on the same stream in different goroutines.
func (cs *clientStream) RecvMsg(m interface{}) error {
	if done, err := cs.readErrorIfDone(); done {
		return err
	}

	select {
	case <-cs.ctx.Done():
		return statusErrorFromContextError(cs.ctx.Err())
	case body, ok := <-cs.rCh:
		if !ok {
			done, err := cs.readErrorIfDone()
			if !done {
				panic("cs.rCh was closed but cs.done == false!")
			}
			return err
		}
		return cs.codec.Unmarshal(body.Data, m)
	}
}

func (cs *clientStream) readLoop() error {
	defer func() {
		cs.rmu.Lock()
		defer cs.rmu.Unlock()
		close(cs.rCh)
		cs.teardown()
		cs.done = true
	}()

	onReady := func(err error, headers metadata.MD) {
		cs.headerErr = err
		cs.header = headers
		cs.ready.Done()
	}

	for {
		rpc, err := cs.r(cs.ctx)
		if err != nil {
			onReady(statusErrorFromContextError(err), nil)
			return err
		}

		if cs.header == nil {
			md, err := internal.ToMetadata(rpc.Header.Headers)
			if err != nil {
				return err
			}
			onReady(nil, md)
		}

		if done, err := errorIfDone(rpc); done {
			cs.trailer = rpc.GetTrailer()
			cs.rErr = err
			return err
		}

		if rpc.Body == nil {
			continue
		}

		select {
		case <-cs.ctx.Done():
			err = statusErrorFromContextError(cs.ctx.Err())
			cs.rErr = err
			return err
		case cs.rCh <- rpc.Body:
			//
		}
	}
}

// statusErrorFromContextError converts a context error or wrapped context error
// into a Status error.
func statusErrorFromContextError(err error) error {
	return status.FromContextError(err).Err()
}

// errorIfDone returns a grpc/status compatible error if the given RPC is the
// last RPC in the stream.
func errorIfDone(rpc *rpcheader.Rpc) (bool, error) {
	if rpc.Trailer == nil {
		return false, nil
	}
	st := rpc.Status
	if st.Code == int32(codes.OK) {
		return true, io.EOF
	}
	sp := spb.Status{
		Code:    st.Code,
		Message: st.Message,
		Details: st.Details,
	}
	return true, status.FromProto(&sp).Err()
}

func (cs *clientStream) readErrorIfDone() (bool, error) {
	cs.rmu.Lock()
	defer cs.rmu.Unlock()

	if !cs.done {
		return false, nil
	}

	return true, cs.rErr
}
